<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Tankred Hase - Whiteout Networks</title><description>Our company was founded in 2013 in Munich. Our mission is to provide secure email that is easy to use and runs on all devices.</description><link>http://blog.whiteout.io/</link><generator>Ghost 0.7</generator><lastBuildDate>Mon, 04 Jan 2016 04:52:43 GMT</lastBuildDate><atom:link href="http://blog.whiteout.io/author/tankred/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Standardizing Secure PGP Private Key Sync</title><description>&lt;p&gt;We've recently updated our specification for private key sync after some discussions with other PGP vendors. The goal of this spec is to formalize and hopefully standardize a very simple protocol that allows interoperability between mail user agents.&lt;/p&gt;

&lt;p&gt;To recap: Our current spec proposes encryption of the user's private key&lt;/p&gt;</description><link>http://blog.whiteout.io/2015/07/06/standardizing-secure-pgp-private-key-sync/</link><guid isPermaLink="false">4e4a76f7-5a44-40ba-ae76-590c6116ed96</guid><category>Security</category><dc:creator>Tankred Hase</dc:creator><pubDate>Mon, 06 Jul 2015 16:28:06 GMT</pubDate><content:encoded>&lt;p&gt;We've recently updated our specification for private key sync after some discussions with other PGP vendors. The goal of this spec is to formalize and hopefully standardize a very simple protocol that allows interoperability between mail user agents.&lt;/p&gt;

&lt;p&gt;To recap: Our current spec proposes encryption of the user's private key using a standard symmetric key encrypted OpenPGP message and a high entropy passphrase that is generated for the user. This passphrase or &lt;em&gt;backup code&lt;/em&gt; is meant to be written down or stored in a user’s password manager. The encrypted PGP key is then stored on the mail server in a dedicated IMAP folder so that multiple mail user agents can access it. The goal here is to be able to read your encrypted messages on all of your devices and from all types of mail clients.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/whiteout-io/mail-html5/wiki/Secure-OpenPGP-Key-Pair-Synchronization-via-IMAP"&gt;Read the full spec here&lt;/a&gt;&lt;/p&gt;

&lt;h1 id="gettingfeedbackfromthecommunity"&gt;Getting Feedback from the Community&lt;/h1&gt;

&lt;p&gt;We presented the first version of our spec at &lt;a href="https://www.gnupg.org/blog/20150426-openpgp-summit.html"&gt;OpenPGP summit in April 2015&lt;/a&gt;. There we got invaluable feedback from Werner Koch of GPG, Koto of Google, and Thomas of Mailvelope. Their feedback helped shape the current version of the spec and simplified the work required by implementors to add support for key sync.&lt;/p&gt;

&lt;p&gt;Since then we've stayed in contact with Mailvelope and developers from 1&amp;amp;1 who have already implemented the protocol's storage format. Mailvelope is used by many webmail providers such as Deutsche Telekom, 1&amp;amp;1, Web.de and GMX.&lt;/p&gt;

&lt;p&gt;We also posted the proposal on multiple outlets including the GnuPG mailing list, the OpenPGP.js mailing list, as well as the Google End-to-End GitHub repository.&lt;/p&gt;

&lt;p&gt;First of all thank you for your feedback so far. There are some open issues regarding storage of private subkeys (which has been added to the spec) as well as syncing the user's local public key ring (which is out of scope and should be specified in a separate spec). All in all though it seems the first round of feedback is quite positive as people see the need for such a standard.&lt;/p&gt;

&lt;h1 id="nextsteps"&gt;Next Steps&lt;/h1&gt;

&lt;p&gt;Our goal is to standardize the proposal as an RFC once at least two vendors have a working implementation out in the wild. This is a similar to how web standards are developed, as crucial feedback from implementers is needed &lt;strong&gt;before&lt;/strong&gt; standardizing.&lt;/p&gt;

&lt;p&gt;We will also present the current version of our spec at the upcoming OpenPGP summit and discuss our experience implementing and using the standard in production.&lt;/p&gt;

&lt;p&gt;We hope to see support for encrypted key sync in all major implementations of OpenPGP such as GnuPG, Thunderbird+Enigmail, GPGTools for Mac, Gpg4win, Mailvelope, Mailpile, Google/Yahoo End-to-End and of course our very own Whiteout Mail.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;P.S. if I forgot anyone in the list above and you’re interested in implementing the spec, just drop me a line at &lt;a href="mailto:tankred@whiteout.io"&gt;tankred@whiteout.io&lt;/a&gt;. Thanks!&lt;/em&gt;&lt;/p&gt;</content:encoded></item><item><title>Cross-platform with Chrome Apps - a Developer Diary</title><description>&lt;p&gt;When we started &lt;a href="https://whiteout.io"&gt;whiteout.io&lt;/a&gt; in 2013, our goal was to provide end-to-end encrypted email that is easy to use and that runs on all devices. We had a lot of technical discussions on which platform to use for development, but in the end decided to make a bet on&lt;/p&gt;</description><link>http://blog.whiteout.io/2015/05/09/cross-platform-with-chrome-apps-a-developer-diary/</link><guid isPermaLink="false">84bc1b72-6de1-4038-8c30-e1e3fb8f4003</guid><category>Product</category><dc:creator>Tankred Hase</dc:creator><pubDate>Sat, 09 May 2015 15:25:56 GMT</pubDate><content:encoded>&lt;p&gt;When we started &lt;a href="https://whiteout.io"&gt;whiteout.io&lt;/a&gt; in 2013, our goal was to provide end-to-end encrypted email that is easy to use and that runs on all devices. We had a lot of technical discussions on which platform to use for development, but in the end decided to make a bet on the web and also its rate of progression as a foundation for cross-platform app development. This is what the app looks like today:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/05/placeit_2.png" alt="Whiteout Mail Screenshots"&gt;&lt;/p&gt;

&lt;p&gt;This decision was not obvious at the time given the recent developments from &lt;a href="http://www.theverge.com/2012/8/23/3262782/facebook-for-ios-native-app"&gt;Facebook&lt;/a&gt; and &lt;a href="http://venturebeat.com/2013/04/17/linkedin-mobile-web-breakup/"&gt;LinkedIn&lt;/a&gt; shifting away from HTML5 to a native apps strategy. And for good reason. &lt;a href="http://techcrunch.com/2014/04/01/mobile-app-usage-increases-in-2014-as-mobile-web-surfing-declines/"&gt;Recent data shows&lt;/a&gt; that mobile users are spending more time in apps than on the mobile web. Since many apps are written with web technology it's not clear if this is because of native vs. web. But it’s safe to assume one aspect is that native user interfaces are often perceived as faster and more fluid than their HTML5 counterparts.&lt;/p&gt;

&lt;p&gt;This does not mean that fast and fluid user experiences cannot be built using web technology. In fact after Facebook announced its shift to native, Sencha released a proof of concept called &lt;a href="http://www.sencha.com/blog/the-making-of-fastbook-an-html5-love-story"&gt;fastbook&lt;/a&gt;, which showed that it is indeed possible to build native like app experiences using nothing but web technology. It was clear that it was cheaper and easier to build a great experience for a single platform using native. But since we wanted Whiteout Mail to run everywhere, we needed a more scalable approach.&lt;/p&gt;

&lt;h2 id="thebet"&gt;The bet&lt;/h2&gt;

&lt;p&gt;Inspired by fastbook and some other apps and ui frameworks that we had been testing internally for our first proof of concept implementation of Whiteout Mail, we decided to make a bet on HTML5. This bet was based on the following hypotheses:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Evergreen browsers such as Chrome and Firefox are increasing the rate of innovation on the web and these would inevitably lead to evergreen WebViews that are used as runtimes in frameworks such as Cordova.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Platform and hardware capabilities, that were traditionally only exposed as native apis via Objective C on iOS or Java on Android, would surface as standardized apis for JavaScript.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Development tools and frameworks would improve to the point where you would press only a button and out comes your app for: Windows, Mac, Linux, iOS, Android.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is why we are excited about Firefox OS. We don't believe it will compete with Android in terms of marketshare anytime soon, but Mozilla has always put pressure on other Browser/OS vendors like Google by spearheading standardization. &lt;/p&gt;

&lt;h2 id="fastforwardtotoday"&gt;Fast forward to today&lt;/h2&gt;

&lt;p&gt;We aren't quite there yet, but having spent the last year developing for the Chrome Apps platform, I think we're pretty damn close.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Android 4.4 was released with the Chromium WebView and Android 5.0 now has an &lt;a href="http://developer.android.com/about/versions/lollipop.html#WebView"&gt;autoupdating evergreen WebView&lt;/a&gt;. To bridge the gap to older devices and OS versions, developers can use the &lt;a href="https://crosswalk-project.org/"&gt;CrossWalk WebView&lt;/a&gt; to deploy an up-to-date runtime to Android 4.0+ (basically &lt;a href="https://developer.android.com/about/dashboards/index.html"&gt;over 90%&lt;/a&gt; of the current Android installed base).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Apple has released a very fast WebView for iOS 8. There are still some warts and I won’t go into all the details here. But you can read about the new WKWebView in &lt;a href="http://www.sencha.com/blog/apple-shows-love-for-html5-with-ios-8"&gt;Sencha’s post&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Many apis like &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/TCPSocket"&gt;raw TCP sockets&lt;/a&gt; that are required for implementing email protocols like IMAP/SMTP aren’t standardized yet. But there are proprietary apis to fill the gap e.g. &lt;a href="https://developer.chrome.com/apps/sockets_tcp"&gt;chrome.sockets&lt;/a&gt; and &lt;a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.networking.sockets.streamsocket.aspx"&gt;StreamSocket&lt;/a&gt;. They can be shimmed easily to work like the emerging standard api using our &lt;a href="https://github.com/whiteout-io/tcp-socket"&gt;tcp-socket shim&lt;/a&gt;. This allowed us to develop &lt;a href="http://emailjs.org"&gt;email.js&lt;/a&gt;, a toolbox for writing cross-platform email applications in pure JavaScript.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="whatarechromeapps"&gt;What are Chrome Apps?&lt;/h2&gt;

&lt;p&gt;For anyone who is new to Chrome Apps here are two resources to get started.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The official documentation: &lt;a href="https://developer.chrome.com/apps/about_apps"&gt;https://developer.chrome.com/apps/about_apps&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A great introduction video: &lt;a href="http://youtu.be/f3NctLbtsNE"&gt;http://youtu.be/f3NctLbtsNE&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="whywechosechromeapps"&gt;Why we chose Chrome Apps&lt;/h2&gt;

&lt;p&gt;The main reasons for us to use chrome apps are:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Security:&lt;/strong&gt; Since Whiteout Mail stores the user's private PGP key locally there are a lot of advantages to Chrome Apps when compared to the normal drive by web. I've written about threat modeling for browser crypto in detail &lt;a href="http://tankredhase.com/2014/04/13/heartbleed-and-javascript-crypto/"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Distribution:&lt;/strong&gt; Most users go to their platform’s native app store to discover new apps. Chrome Apps support packaging for all relevant platforms (Android, iOS, Windows, Mac OS, Linux).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Offline:&lt;/strong&gt; Email clients need to work when users are offline. Users want to read and write messages on a train or a flight. The client should sync whenever there’s a connection but also work when there isn’t one.&lt;/p&gt;

&lt;h2 id="ourexperiencewithchromeapps"&gt;Our Experience with Chrome Apps&lt;/h2&gt;

&lt;p&gt;Building a complete email client in JavaScript with full IMAP / SMTP / MIME / OpenPGP support wasn’t an easy task, but the Chrome Apps platform provided a good foundation for this journey. Here is a brief overview of our experience developing Whiteout Mail.&lt;/p&gt;

&lt;h3 id="thedesktop"&gt;The desktop&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/05/placeit_3.jpg" alt="Screenshot of Whiteout Mail for the desktop"&gt;&lt;/p&gt;

&lt;p&gt;We started on the desktop since that was the first platform Chrome Apps were officially supported. This has turned out to be a good place to start. Chrome Apps are currently the most stable deployment path for cross-platform HTML5 packaged apps. We tried &lt;a href="https://developer.mozilla.org/en-US/Marketplace/Options/Packaged_apps"&gt;Firefox Packaged Apps&lt;/a&gt; but couldn't even &lt;a href="http://stackoverflow.com/questions/24339502/how-to-test-privileged-packaged-apps-on-firefox-for-desktop"&gt;debug them&lt;/a&gt; for the desktop.&lt;/p&gt;

&lt;p&gt;One thing to keep in mind is that Chrome Apps have several more constraints than regular web apps like &lt;a href="https://developer.chrome.com/apps/contentSecurityPolicy"&gt;Content Security Policy (CSP)&lt;/a&gt;. You may need to sandbox certain content into iframes and using apis like eval and inline scripts is not allowed. This is one reason we decided to use angular.js as it &lt;a href="https://docs.angularjs.org/api/ng/directive/ngCsp"&gt;supports CSP&lt;/a&gt; out of the box. One valuable experience we had here is that starting from a constrained architecture is always easier than the other way around. So it's best to start using CSP early if you intend to support Chrome Apps.&lt;/p&gt;

&lt;p&gt;You can try our desktop app &lt;a href="https://chrome.google.com/webstore/detail/whiteout-mail/jjgghafhamholjigjoghcfcekhkonijg"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="android"&gt;Android&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/05/placeit_1.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Next we ported the app to Android using the &lt;a href="https://github.com/MobileChromeApps/mobile-chrome-apps/blob/master/README.md"&gt;Chrome Cordova Apps&lt;/a&gt;. This turned out to be a surprisingly simple task due to the above mentioned Crosswalk WebView. The main challenge here was getting the back button for Android to work correctly. To be fair this was mainly because we forgot to handle the browser history at first in angular. Had we done this right from the beginning, the back button would have worked out of the box.&lt;/p&gt;

&lt;p&gt;You can try the Android app &lt;a href="https://play.google.com/store/apps/details?id=io.whiteout.WhiteoutMail"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="ios"&gt;iOS&lt;/h3&gt;

&lt;p&gt;Finally we went on to tackle iOS. This turned out to be the hardest of the platforms due to some issues with the Chrome Api plugins. Thankfully &lt;a href="https://github.com/orgs/MobileChromeApps/people"&gt;the team&lt;/a&gt; behind Mobile Chrome Apps was very helpful and supportive. Anytime we had an issue, we received a response promptly on GitHub. Bugfixes also landed quickly in upcoming versions of &lt;em&gt;cca&lt;/em&gt; (Chrome Cordova Apps’ command line tool).&lt;/p&gt;

&lt;p&gt;You can try our iOS app &lt;a href="https://itunes.apple.com/us/app/whiteout-mail/id934872032"&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h3 id="theweb"&gt;The Web&lt;/h3&gt;

&lt;p&gt;We were even able to get a full version of the app running on the web using the same code-base as for the Chrome Apps. We did this by extending our tcp-socket shim to use &lt;a href="http://socket.io"&gt;socket.io&lt;/a&gt; (to proxy TCP connections required for IMAP and SMTP) and &lt;a href="https://github.com/digitalbazaar/forge"&gt;Forge&lt;/a&gt; (a JavaScript implementation of TLS). This way we were able to terminate the TLS session on the user’s machine so that our proxy does not see any plaintext user data like passwords or email message content.&lt;/p&gt;

&lt;p&gt;You can try the webmail version of Whiteout Mail &lt;a href="https://mail.whiteout.io"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="thecode"&gt;The code&lt;/h3&gt;

&lt;p&gt;In case you’re interested you can check out all of the &lt;a href="https://github.com/whiteout-io/mail-html5"&gt;code on GitHub&lt;/a&gt; since the Whiteout Mail client is &lt;a href="https://blog.whiteout.io/2014/10/17/webmail-and-open-source/"&gt;open source&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;

&lt;p&gt;The Chrome Apps platform is pretty close to the &lt;em&gt;write once run anywhere&lt;/em&gt; dream developers aspire to. The main advantage to using something like Chrome Apps or Cordova is that you can deploy your web app using each platform's native app store, since this is where most users go to discover new content and apps.&lt;/p&gt;

&lt;p&gt;There are of course still some caveats e.g. missing standardization of certain apis and packaging formats, but time will fix all of these issues. Standardization always trails innovation and without pioneers like Chrome Apps we would have to iterate on these concepts within the standards bodies, which is in nobody’s best interest.&lt;/p&gt;

&lt;p&gt;To get a feeling for where all this is heading here’s a &lt;a href="https://divshot.com/blog/opinion/the-future-of-the-web-according-to-google/"&gt;great summary&lt;/a&gt; of the 2014 Chrome Developer Summit. It seems like Google will be focusing less on proprietary apis in Chrome Apps and more on bringing all of this goodness to the open web. They intend to keep supporting Chrome Apps since it’s the native development platform for Chromebooks but it's clear where the focus will be.&lt;/p&gt;

&lt;p&gt;What does all of this mean for developers? In short I would definitely recommend developing for Chrome Apps. Even if Google decided to deprecate Chrome Apps tomorrow, you could still reuse 99% of your code on the open web (as we have with the Webmail version of Whiteout Mail). So there’s not a lot of risk for vendor lock-in. All in all Chrome Apps have become a very robust development environment and tooling like remote debugging in Chrome has matured to a point that the web now has a productive development workflow.&lt;/p&gt;</content:encoded></item><item><title>Secure PGP Key Sync - A Proposal (cont’d)</title><description>&lt;p&gt;This post is a continuation of a &lt;a href="https://blog.whiteout.io/2014/07/07/secure-pgp-key-sync-a-proposal/"&gt;previous post on encrypted sync of a user’s private PGP key&lt;/a&gt;. In the previous post we discussed that in today’s multi screen world it is mandatory to be able to read and write encrypted messages on several devices at once. In&lt;/p&gt;</description><link>http://blog.whiteout.io/2015/04/08/secure-pgp-key-sync-a-proposal-contd/</link><guid isPermaLink="false">8b716b15-f708-4dc1-b6c1-2bf78fa2f7b0</guid><category>Security</category><category>Product</category><dc:creator>Tankred Hase</dc:creator><pubDate>Wed, 08 Apr 2015 12:12:25 GMT</pubDate><content:encoded>&lt;p&gt;This post is a continuation of a &lt;a href="https://blog.whiteout.io/2014/07/07/secure-pgp-key-sync-a-proposal/"&gt;previous post on encrypted sync of a user’s private PGP key&lt;/a&gt;. In the previous post we discussed that in today’s multi screen world it is mandatory to be able to read and write encrypted messages on several devices at once. In this context we proposed a specification for encrypted key synchronization. This post will once again highlight this topic by introducing a new simplified version of the specification.&lt;/p&gt;

&lt;h2 id="specificationupdateanrfc"&gt;Specification Update - an RFC&lt;/h2&gt;

&lt;p&gt;The new spec is published in our GitHub wiki and our intent is to publish this as an RFC for standardization, as other OpenPGP user agents such as Enigmail have expressed interest:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/whiteout-io/mail-html5/wiki/Secure-OpenPGP-Key-Pair-Synchronization-via-IMAP"&gt;Secure OpenPGP Key Pair Synchronization via IMAP (RFC)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In a nutshell, the new spec is much simpler than our initial proposal. The encrypted private key is no longer stored on our server, but rather just stored in the user’s IMAP server. This not only removes the need to add a proprietary authentication mechanism, since IMAP servers already provide password (as well as 2-factor) based authentication, it also reduces the complexity of the overall protocol. This reduces the attack surface since a simpler protocol is easier to reason about, audit, and implement correctly.&lt;/p&gt;

&lt;h2 id="userexperience"&gt;User Experience&lt;/h2&gt;

&lt;p&gt;The user experience has also been simplified. The user no longer needs to be logged into another mail client to receive the recovery token required for authentication. The user simply needs to have an active IMAP session open, which is the case anyway for Whiteout Mail.&lt;/p&gt;

&lt;h3 id="upload"&gt;Upload&lt;/h3&gt;

&lt;p&gt;Key sync is now mandatory and the first time a user sets up Whiteout Mail they are prompted to write down a backup code.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/04/upload-1.png" alt="Write down backup code"&gt;&lt;/p&gt;

&lt;p&gt;They are then prompted to confirm the backup code.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/04/upload-2.png" alt="Confirm backup code"&gt;&lt;/p&gt;

&lt;p&gt;Now the user’s key pair is backed up in case they lose their device or in case they want to sync to a new device.&lt;/p&gt;

&lt;h3 id="download"&gt;Download&lt;/h3&gt;

&lt;p&gt;To add a new device, the user simply logs into Whiteout Mail with their email address. The app will automatically detect a synced key and will prompt the user to enter the backup code.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/04/download.png" alt="Enter backup code"&gt;&lt;/p&gt;

&lt;p&gt;And done! It’s that easy.&lt;/p&gt;

&lt;h2 id="tryitnow"&gt;Try it now&lt;/h2&gt;

&lt;p&gt;To try out the new key sync, just head on over to our &lt;a href="https://whiteout.io/#product"&gt;download page&lt;/a&gt; and install the app for your platform.&lt;/p&gt;

&lt;h2 id="acknowledgements"&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;We want to thank &lt;a href="https://cure53.de"&gt;Cure53&lt;/a&gt; who have worked together with us to design and review the security of the new protocol.&lt;/p&gt;</content:encoded></item><item><title>Making PGP Key Management Invisible So Johnny Can Encrypt</title><description>&lt;p&gt;We’ve written about usability for PGP email encryption before. In a recent post we’ve touched on the &lt;a href="https://blog.whiteout.io/2015/01/29/why-alice-has-a-problem-if-bob-cant-encrypt/"&gt;usability of crypto apps&lt;/a&gt; in general and published a specification for &lt;a href="https://blog.whiteout.io/2014/07/07/secure-pgp-key-sync-a-proposal/"&gt;multi-device sync&lt;/a&gt; of a user’s private key. &lt;/p&gt;

&lt;p&gt;This post will address one of the hardest problems in PGP, namely&lt;/p&gt;</description><link>http://blog.whiteout.io/2015/02/06/making-pgp-key-management-invisible-so-johnny-can-encrypt/</link><guid isPermaLink="false">ed72321f-4199-42d1-a348-3c9ef4124bd6</guid><category>UX</category><dc:creator>Tankred Hase</dc:creator><pubDate>Fri, 06 Feb 2015 18:19:11 GMT</pubDate><media:content url="http://blog.whiteout.io/content/images/2015/02/Bildschirmfoto-2015-02-06-um-19-28-22-1.png" medium="image"/><content:encoded>&lt;img src="http://blog.whiteout.io/content/images/2015/02/Bildschirmfoto-2015-02-06-um-19-28-22-1.png" alt="Making PGP Key Management Invisible So Johnny Can Encrypt"&gt;&lt;p&gt;We’ve written about usability for PGP email encryption before. In a recent post we’ve touched on the &lt;a href="https://blog.whiteout.io/2015/01/29/why-alice-has-a-problem-if-bob-cant-encrypt/"&gt;usability of crypto apps&lt;/a&gt; in general and published a specification for &lt;a href="https://blog.whiteout.io/2014/07/07/secure-pgp-key-sync-a-proposal/"&gt;multi-device sync&lt;/a&gt; of a user’s private key. &lt;/p&gt;

&lt;p&gt;This post will address one of the hardest problems in PGP, namely key discovery of a contact’s public key.&lt;/p&gt;

&lt;h2 id="uxvssecuritytradeoff"&gt;UX vs. Security Tradeoff&lt;/h2&gt;

&lt;p&gt;Much has been written about the usability of PGP. Recently Matthew Green wrote a &lt;a href="http://blog.cryptographyengineering.com/2014/08/whats-matter-with-pgp.html"&gt;great post&lt;/a&gt; titled &lt;em&gt;What's the matter with PGP?&lt;/em&gt;. The post talks a lot about technical aspects of the protocol, but also about what should be addressed in terms of usability for key management:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;A proper approach to key management.&lt;/strong&gt; This could be anything from centralized key management as in Apple's iMessage -- which would still be better than nothing -- to a decentralized (but still usable) approach like the one offered by Signal or OTR. Whatever the solution, in order to achieve mass deployment, keys need to be made much more manageable or else submerged from the user altogether.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I agree completely. It’s not the user’s fault that the protocol is so complicated and they shouldn’t be burdened with it. That’s why we’ve added automatic public key lookup for incoming and outgoing messages in our PGP mail client &lt;a href="https://whiteout.io/"&gt;Whiteout Mail&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Here’s a look at how it works.&lt;/p&gt;

&lt;h2 id="howwhiteoutmailpublickeydiscoveryworks"&gt;How Whiteout Mail Public Key Discovery Works&lt;/h2&gt;

&lt;p&gt;Up until now, Whiteout Mail had it’s own closed key server under &lt;a href="https://keys.whiteout.io"&gt;keys.whiteout.io&lt;/a&gt;. We basically did what Matthew Green proposed. We created a centralized authority that would accept an uploaded public key only after validating a user’s email address (proving ownership of the key). Keys were fetched automatically while reading and writing in Whiteout Mail and messages were encrypted by default. This worked quite well, but only from Whiteout user to Whiteout user. If users wanted to write PGP messages to non-whiteout users, they would have to find the recipient’s public PGP key and manually import it as a file. This is not only tedious but also impossible on platforms like iOS, where apps don’t have access to the filesystem.&lt;/p&gt;

&lt;p&gt;So users asked for support of standard &lt;a href="http://en.wikipedia.org/wiki/Key_server_%28cryptographic%29"&gt;HKP key servers&lt;/a&gt; and there was a &lt;a href="https://github.com/whiteout-io/mail-html5/issues/236"&gt;discussion&lt;/a&gt; on how to best handle key import.&lt;/p&gt;

&lt;h3 id="automatichkplookupinwhiteoutmail"&gt;Automatic HKP Lookup in Whiteout Mail&lt;/h3&gt;

&lt;p&gt;We felt strongly that encryption should just work for average users and that most should never be exposed to key management in the first place. Here’s what we came up with:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;When a user composes a new message to a recipient’s email address, the client first queries the local keychain. This keychain includes cached keys imported from any source.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If the recipient’s key is not found in the local key ring the client then queries our own key server. These keys have been validated by our key server to ensure recipient key ownership.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If there is no key for the recipient on our key server, a list of well known HKP key servers (e.g. pgp.mit.edu) is queried. If a key is found, it is imported to the local key ring by a TOFU (trust on first use) principle.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If a key is found, it will be used to encrypt the message. The user will also be notified in the UI by changing the color from red (insecure) to blue (secure).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;"But what if an attacker uploads a fake public key to pgp.mit.edu and users don’t notice?"&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For most users this is not an issue as the attacker would need access to the recipient’s mailbox to decrypt the message (which has been encrypted to the wrong key). It depends on the type of attacker of course. State level adversaries can intercept a message in transit. But this implies an active/targeted attack. If this is your threat model, you will want to verify the PGP key fingerprint over a second channel anyway. Most users on the other hand would be helped by protecting them against a passive adversary like dragnet surveillance.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So why design our encryption solution for an edge case and ignore the common case which would lead to a more usable experience for the masses?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Even with TOFU key lookup, users can later always navigate to the contacts menu and verify a recipient’s key fingerprint if they need to. There is a trade off between security and usability here. But users get transparency when they need it and it's as painless as possible in most cases.&lt;/p&gt;

&lt;p&gt;In practice encrypting to the wrong key will most likely cause the recipient to reply with something like this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;"Hey, can't read your message. Did you use my current key? Here you go... "&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is the only case the user will need to be exposed to key management. For this case Whiteout Mail offers key import via copy/paste, file import, or manual HKP server lookup. Once the correct key is imported, all future conversations between those users will be encrypted correctly.&lt;/p&gt;

&lt;h3 id="tofutrustonfirstuseworks"&gt;TOFU (Trust On First Use) Works&lt;/h3&gt;

&lt;p&gt;Sysadmins use TOFU everyday when they login to a new host via ssh. This is what the workflow for most users feels like:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/Bildschirmfoto-2015-02-07-um-18-17-08.png" alt="Making PGP Key Management Invisible So Johnny Can Encrypt"&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
  &lt;li&gt;Type &lt;strong&gt;ssh username@hostname&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Read a security warning with some random characters  &lt;/li&gt;
  &lt;li&gt;Type &lt;strong&gt;yes&lt;/strong&gt; ... because &lt;em&gt;"who checks that stuff anyway"&lt;/em&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Do you always confirm the RSA fingerprint when ssh'ing into a new machine? If we are brutally honest with ourselves, this is how encryption systems are being used out there in the wild. But it's still more secure than using a plaintext connection over telnet.&lt;/p&gt;

&lt;h2 id="howweimplementedhkpsupportforwhiteoutmail"&gt;How We Implemented HKP Support for Whiteout Mail&lt;/h2&gt;

&lt;p&gt;Before integrating HKP support, we looked at current key server implementations and saw that it wasn’t possible to integrate them into our app, due to some missing features.&lt;/p&gt;

&lt;h3 id="missingfeaturesinhkptoday"&gt;Missing features in HKP today&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;No SSL support&lt;/li&gt;
&lt;li&gt;Bad availability/scalability&lt;/li&gt;
&lt;li&gt;No email address validation of uploaded keys&lt;/li&gt;
&lt;li&gt;No CORS support (&lt;a href="http://lists.gnupg.org/pipermail/gnupg-users/2014-April/049446.html"&gt;see here&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We couldn’t make cross origin requests to HKP servers from the web version of our app. So instead we decided to use our current key server as a proxy and query multiple HKP servers for maximum availability and performance. Here’s a quick summary of our current key server architecture:&lt;/p&gt;

&lt;h3 id="whiteoutpublickeyserver"&gt;Whiteout Public Key Server:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Modern REST style api&lt;/li&gt;
&lt;li&gt;SSL only&lt;/li&gt;
&lt;li&gt;CORS support&lt;/li&gt;
&lt;li&gt;Email address validation of uploaded key&lt;/li&gt;
&lt;li&gt;Automatic lookup on multiple HKP servers (first request wins)&lt;/li&gt;
&lt;li&gt;Automatic upload of public keys to HKP servers (after validation on our server)&lt;/li&gt;
&lt;li&gt;Autoscaling application server&lt;/li&gt;
&lt;li&gt;MongoDB cluster&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="restapi"&gt;REST API:&lt;/h3&gt;

&lt;p&gt;Host: &lt;strong&gt;&lt;a href="https://keys.whiteout.io"&gt;https://keys.whiteout.io&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id="fetchkeyget"&gt;Fetch key (GET)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;By email (short hand)
&lt;strong&gt;/:emailAddress&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;By email (long)
&lt;strong&gt;/publickey/user/:emailAddress&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;By key ID
&lt;strong&gt;/publickey/key/:keyId&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="uploadkeyput"&gt;Upload key (PUT)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Upload new key
&lt;strong&gt;/publickey/user/:emailAddress/key/:keyId&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;

&lt;p&gt;Using this api any PGP user (even non-Whiteout users) can link their pgp key with &lt;strong&gt;&lt;a href="https://keys.whiteout.io/emailAddress"&gt;https://keys.whiteout.io/emailAddress&lt;/a&gt;&lt;/strong&gt;. And any pgp user will be able to send and receive encrypted messages with Whiteout users, since HKP support goes both ways.&lt;/p&gt;

&lt;p&gt;The main advantage to the approach is that encryption will just work. Technically savvy GPG users will be able to send and receive messages with average users like Johnny. Can't get your Johnny to use GPG? Just send him over to &lt;a href="https://mail.whiteout.io"&gt;mail.whiteout.io&lt;/a&gt; and leave your GPG setup untouched.&lt;/p&gt;

&lt;p&gt;We look forward to your feedback and ideas. Please don't hesitate to ring us up on &lt;a href="https://twitter.com/whiteoutio"&gt;twitter&lt;/a&gt; or via &lt;a href="mailto:info@whiteout.io"&gt;mail&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Happy encrypting!&lt;/p&gt;</content:encoded></item><item><title>New Responsive Design</title><description>&lt;p&gt;At Whiteout we not only want end-to-end encrypted email to be easy to use, but also powerful enough to address more and more of your email needs. That's why we've been working hard over the last few months to rebuild the Whiteout Mail experience from the ground up. Today we're&lt;/p&gt;</description><link>http://blog.whiteout.io/2014/12/08/new-responsive-design/</link><guid isPermaLink="false">77778b20-7b01-4ecf-9a61-74e83e3efe7c</guid><category>Product</category><dc:creator>Tankred Hase</dc:creator><pubDate>Mon, 08 Dec 2014 17:42:09 GMT</pubDate><content:encoded>&lt;p&gt;At Whiteout we not only want end-to-end encrypted email to be easy to use, but also powerful enough to address more and more of your email needs. That's why we've been working hard over the last few months to rebuild the Whiteout Mail experience from the ground up. Today we're excited to share what we've come up with.&lt;/p&gt;

&lt;h2 id="thenewdesktop"&gt;The New Desktop&lt;/h2&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/placeit_3-3.jpg" alt="New Desktop Layout"&gt;&lt;/p&gt;

&lt;p&gt;The Whiteout Mail client is designed to run on all your devices, desktop, tablets, smartphones. We have now added an additional layout to our responsive design that is optimized for the larger screen you typically have on a desktop or laptop computer. You will recognize the familiar layout displaying all your folders in the lefthand pane from the desktop mail clients you normally use.&lt;/p&gt;

&lt;h2 id="completelyresponsive"&gt;Completely Responsive&lt;/h2&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/placeit_2-4.png" alt="Responsive Design"&gt;&lt;/p&gt;

&lt;p&gt;If you resize the window it will automatically adopt the layouts for the tablet or the smartphone screen sizes. The new desktop layout is available both in the packaged app as well as in the webmail version of Whiteout Mail. To try it out just head over to &lt;a href="https://mail.whiteout.io"&gt;mail.whiteout.io&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="standardsbasedandopensource"&gt;Standards based and Open Source&lt;/h2&gt;

&lt;p&gt;Even though the user interface changed, the core of our application remains the same. We are committed to building on established open standards such as OpenPGP, IMAP and SMTP. This means you can use the new client with your existing email account and write PGP messages to non-whiteout users.&lt;/p&gt;

&lt;p&gt;As always the source code is open. &lt;a href="https://github.com/whiteout-io/mail-html5"&gt;Check it out&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="advancenoticewhiteoutmailboxprivatebeta"&gt;Advance Notice: Whiteout Mailbox Private Beta&lt;/h2&gt;

&lt;p&gt;We have been working on Whiteout Mailbox, a new email service that will be available as an additional secure mailbox for your confidential communication needs. Or as your new mailbox where you send and receive all your mail. Whiteout Mailbox is hosted in Germany and will offer important security benefits, especially at-rest encryption of your messages when they are stored in the cloud. Let us know if you want to take part in the upcoming private beta at &lt;a href="mailto:support@whiteout.io"&gt;support@whiteout.io&lt;/a&gt;.&lt;/p&gt;</content:encoded></item><item><title>Webmail &amp; Open Source</title><description>&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/Bildschirmfoto-2014-10-13-um-16-56-46-3.png" alt="Whiteout Mail is now available for the web!"&gt;&lt;/p&gt;

&lt;p&gt;We have big plans for Whiteout Mail and today we'd like to share a few more pieces of the puzzle: Placing the mail client under the MIT open source license to encourage community participation, announcing support for trusted web hosting, and a preview of the premium services that we are&lt;/p&gt;</description><link>http://blog.whiteout.io/2014/10/17/webmail-and-open-source/</link><guid isPermaLink="false">4785193d-55c6-46ff-9b4e-6190cd903388</guid><category>Product</category><dc:creator>Tankred Hase</dc:creator><pubDate>Fri, 17 Oct 2014 10:32:39 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/Bildschirmfoto-2014-10-13-um-16-56-46-3.png" alt="Whiteout Mail is now available for the web!"&gt;&lt;/p&gt;

&lt;p&gt;We have big plans for Whiteout Mail and today we'd like to share a few more pieces of the puzzle: Placing the mail client under the MIT open source license to encourage community participation, announcing support for trusted web hosting, and a preview of the premium services that we are working on.&lt;/p&gt;

&lt;h2 id="opensourcelicense"&gt;Open Source License&lt;/h2&gt;

&lt;p&gt;We are very excited to announce that starting today, the complete Whiteout Mail client will be put under the MIT open source license. Our client code has been &lt;a href="https://github.com/whiteout-io/mail-html5"&gt;open for inspection&lt;/a&gt; from day one, but the MIT license will allow us to build Whiteout Mail together with a very diverse open source community. We welcome non-profit contributors as well as commercial partners at every level of the stack. This is why we are very excited to see that Mozilla is using our &lt;a href="https://bugzilla.mozilla.org/show_bug.cgi?id=885110"&gt;email.js libraries in the Firefox OS 2.1 mail client&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We hope Whiteout Mail will become for multi-device PGP and the Web what Thunderbird is for the desktop and we look forward to your contributions and ideas!&lt;/p&gt;

&lt;h2 id="trustedwebhosting"&gt;Trusted Webhosting&lt;/h2&gt;

&lt;p&gt;We understand that different users may have different threat models in mind when selecting a solution for encrypted email. This is why starting today we will support Whiteout for three levels of trust:&lt;/p&gt;

&lt;h3 id="1packagedappinstallation"&gt;1. Packaged App Installation&lt;/h3&gt;

&lt;p&gt;This is the default and most secure mode. We provide official builds for Chrome, Android and iOS (coming soon). There is no need to trust us when using these apps, as they are installed as signed apps from an App Store and the installed source code can be compared with our tagged releases on GitHub.&lt;/p&gt;

&lt;h3 id="2trustedwebhosting"&gt;2. Trusted Webhosting&lt;/h3&gt;

&lt;p&gt;Starting today, you will be able to download and install WM to your own trusted web server and use it in the browser. Use cases could include your company's server or setting up your own self-hosted solution.&lt;/p&gt;

&lt;p&gt;The cool thing is that the IMAP/SMTP logic is still implemented completely in js on the client. TCP traffic is proxied with the TLS session terminated in the user's browser using socket.io and js-crypto (&lt;a href="https://github.com/digitalbazaar/forge"&gt;forge&lt;/a&gt;). This means that the proxy on the webserver will see only encrypted traffic and never any user data like IMAP/SMTP passwords or message contents.&lt;/p&gt;

&lt;p&gt;Like the packaged app, user data such as your private PGP key, are persisted only on the client (in IndexedDB), and the app's code is even cached for offline use (using HTML5 AppCache). The Application can be installed to the device’s homescreen and is configured to notify the user when the AppCache is updated. This makes the user experience as transparent as possible and works similarly to updates via an App Store.&lt;/p&gt;

&lt;p&gt;Since users are getting the js crypto code from the web server, there will be a trust relationship to that server. But if this is your own trusted server this is ok. The web server enforces CSP (Content Security Policy) and HSTS (HTTP Strict Transport Security) to mitigate cross site scripting and man-in-the-middle attacks.&lt;/p&gt;

&lt;h3 id="3managedwebmail"&gt;3. Managed Webmail&lt;/h3&gt;

&lt;p&gt;The third mode of operation is managed hosting by us. Due to the TLS connection from the browser to the IMAP server, our proxy will never see any of your data. But you will be trusting the Whiteout webserver to deliver the correct code to your browser in this mode. The threat model for this approach is discussed &lt;a href="https://blog.whiteout.io/2014/04/13/heartbleed-and-javascript-crypto/"&gt;here&lt;/a&gt; and we will do our best to inform users in plain english about the security trade-off they are making.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note that this mode of operation does not protect users against active attacks from Whiteout Networks, e.g. should we receive a subpoena for a specific user. But it will protect users against passive attacks, like dragnet surveillance and wiretapping of government agencies.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We think it's important that users are able to make an informed decision about how much convenience they want to give up for security. If you're a concerned citizen and don't want too much hassle to protect your email privacy, this might be the right mode for you. Just open your favorite web browser and navigate to  &lt;a href="https://mail.whiteout.io"&gt;mail.whiteout.io&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="premiumservices"&gt;Premium Services&lt;/h2&gt;

&lt;p&gt;Although the WM client is completely free and open source, we will offer paid options for power users and companies in the near future.&lt;/p&gt;

&lt;h3 id="fullyencryptedwhiteoutmailbox"&gt;Fully encrypted Whiteout Mailbox&lt;/h3&gt;

&lt;p&gt;We will offer paid mailboxes under the wmail.io domain. This is a fully managed mailbox with extra privacy features built in.&lt;/p&gt;

&lt;p&gt;Upon uploading your public PGP key to our key-server, all incoming messages will be encrypted on the fly to your public key before being stored on our servers (hosted in Europe). Also: unlike free mail providers like Gmail, we will not log user data or scan your emails to show you advertising. With Whiteout you are the customer, not the product!&lt;/p&gt;

&lt;p&gt;Messages stored in wmail.io will only be accessible with the private PGP key, stored on your device. This will protect your messages at rest on the server against hackers and identity theft. You will even be able to use other mail clients with wmail.io (like Apple Mail together with GPGtools or Thunderbird with Enigmail).&lt;/p&gt;

&lt;p&gt;Remember: your email address is your identity on the internet and now you can protect it with an extra layer of security.&lt;/p&gt;

&lt;p&gt;Expect to hear more about how to sign up for early access to the Whiteout Mailbox private beta program.&lt;/p&gt;

&lt;h3 id="premiumservicesandvolumelicensing"&gt;Premium Services and Volume Licensing&lt;/h3&gt;

&lt;p&gt;Using the Whiteout Mail client is free. Users who want to get the best possible experience will be able to select a paid premium service, which includes automatic updates, secure key synchronization for multiple devices, as well as a support hotline. Organizations who are interested in deploying encrypted email across larger groups of users will benefit from our volume licensing program. Watch this space for further updates. &lt;/p&gt;

&lt;p&gt;Happy encrypting!&lt;/p&gt;</content:encoded></item><item><title>Secure PGP Key Sync - A Proposal</title><description>&lt;p&gt;In today's multi device world it's absolutely mandatory that the user's data be available on all screens at all times. Yet secure email protocols such as PGP were designed more than 20 years ago. This means that for encrypted email the status quo up until now has basically been: Either&lt;/p&gt;</description><link>http://blog.whiteout.io/2014/07/07/secure-pgp-key-sync-a-proposal/</link><guid isPermaLink="false">985acaa6-4710-4d5e-b9fa-e9a17db9ac5a</guid><category>Security</category><category>Privacy</category><dc:creator>Tankred Hase</dc:creator><pubDate>Mon, 07 Jul 2014 13:27:45 GMT</pubDate><content:encoded>&lt;p&gt;In today's multi device world it's absolutely mandatory that the user's data be available on all screens at all times. Yet secure email protocols such as PGP were designed more than 20 years ago. This means that for encrypted email the status quo up until now has basically been: Either you're on the device your key is on or you’re out of luck. Like this poor sap that got an encrypted email on his iPhone:&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/iPhone-Mail-1.PNG" alt="PGP encrypted message on iPhone"&gt;&lt;/p&gt;

&lt;p&gt;Needless to say there are many ways to go about solving this problem. One could simply throw out the last 30 years of protocols like SMTP, IMAP and PGP and reinvent the wheel like &lt;a href="http://darkmail.info/"&gt;DarkMail&lt;/a&gt;, but we at Whiteout believe in building on existing standards, since they aren't going away any time soon. This does not mean that we don't applaud the important work of creating a modern set of protocols for asynchronous messaging that solve meta-data security and forward secrecy. But given today's landscape, the large-scale adoption of such an approach is years away. In this post we'd like to discuss our approach at tackling multi device encrypted email.&lt;/p&gt;

&lt;h2 id="theburdenofkeymanagement"&gt;The burden of key management&lt;/h2&gt;

&lt;p&gt;Studies have shown time and time again that if users are exposed to the complexities of managing their own keys, many will fail.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;"Three of the twelve test participants (P4, P9, and P11) accidentally emailed the secret to the team members without encryption. Two of the three (P9 and P11) realized immediately that they had done so, but P4 appeared to believe that the security was supposed to be transparent to him and that the encryption had taken place. In all three cases the error occurred while the participants were trying to figure out the system by exploring." - &lt;em&gt;&lt;a href="http://www.gaudior.net/alma/johnny.pdf"&gt;Why Johnny Can’t Encrypt: A Usability Evaluation of PGP 5.0&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is why we, as a service provider for encrypted email, believe that one major way we can provide value to users is key management. Not only does Whiteout Mail automate public key discovery when typing in a recipient's email address, we also want to make private key management so easy that it becomes basically invisible to users (unless users explicitly want to dig deeper, of course).&lt;/p&gt;

&lt;h2 id="whiteoutkeysyncuserexperiencetechnologypreview"&gt;Whiteout Key Sync User Experience - Technology Preview&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;DISCLAIMER: The following specification as well as the current version of the reference implementation are definitely work in progress and should not yet be considered for production use. We reserve the right to delete private keys from our sync service during the experimental phase in case we need to update our storage format or encryption protocol. We would also very much appreciate any feedback and suggestions. Feel free to &lt;a href="https://twitter.com/whiteoutio"&gt;tweet&lt;/a&gt; us or drop us &lt;a href="mailto:mail.support@whiteout.io"&gt;an email&lt;/a&gt; (&lt;a href="https://keys.whiteout.io/mail.support@whiteout.io"&gt;PGP Key&lt;/a&gt;).&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Now that we've got that out of the way, if you're feeling adventurous you can try key sync today by installing the &lt;a href="https://whiteout.io/#product"&gt;Whiteout Mail App&lt;/a&gt; and syncing your test keys between e.g. your Desktop PC and your Chromebook (Android App coming very soon). The setup process itself borrows heavily from existing products like Firefox Sync and the iCloud keychain from Apple. Both products allow users to sync their passwords and other personal data in an encrypted form.&lt;/p&gt;

&lt;p&gt;It's important to note that multi device sync for Whiteout Mail is completely optional. We understand that there are users that would never sync their private PGP key (even in encrypted form) and we absolutely respect that. But if you do want to use Whiteout Mail on multiple devices, then here's what the user experience for Whiteout Key Sync looks like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The user starts Whiteout Mail on the Computer they first installed the app on. Either the app generated a new PGP key pair for the user on initial startup (default behavior for average users and first time PGPers) or the user chose to import an existing PGP key (option for experienced PGP users). The user must then activate &lt;code&gt;Key sync&lt;/code&gt; from the menu and is greeted with this setup screen:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/Keychain-code-setup.png" alt="Key sync setup"&gt;&lt;/p&gt;

&lt;p&gt;In this step a random &lt;code&gt;keychain code&lt;/code&gt; is generated for the user which is used to encrypt the user’s private key on their computer before sync. From a UX perspective the code basically replaces the private PGP key, as the user must write down the &lt;code&gt;keychain code&lt;/code&gt; and keep it in a safe place.&lt;/p&gt;

&lt;p&gt;The code is never shared or made available to Whiteout, so we cannot decrypt the user’s PGP key. The idea here is that the long asymmetric PGP key is replaced by a short (but still high-entropy) symmetric key, which can be written down easily and typed into a touch screen. (For all the technical details, please check out the protocol specification at the end of this post.)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The user then installs the Whiteout Mail app on a new device. If sync was activated for his account the app will know this and ask the user for a recovery token which is sent to them via Email or SMS:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/Recovery-token-input-2.png" alt="Recovery token input on Nexus 5"&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;After the user has been authenticated, they will be asked to provide their keychain code. Upon successful entry, the encrypted private PGP key will be sent to the device, decrypted locally and stored on the device.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/Keychain-code-input-1.png" alt="Keychain code input on Nexus 5"&gt;&lt;/p&gt;

&lt;p&gt;And done! The user can now read and write encrypted messages on multiple devices.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/Mail-list-Nexus-5-1.png" alt="Mail list on Nexus 5"&gt;&lt;/p&gt;

&lt;p&gt;It's important to note that this setup process is required only once when setting up the new device. This means that the keychain code can conveniently be kept in a safe place and does not have to be with the user at all times.&lt;/p&gt;

&lt;p&gt;Now that we've briefly touched what the user experience looks like, here's a  technical overview of the encryption protocol.&lt;/p&gt;

&lt;h2 id="whiteoutprivatekeysyncspecification"&gt;Whiteout Private Key Sync Specification&lt;/h2&gt;

&lt;p&gt;Importing/exporting the user’s private PGP key to their various devices is a challenge on non desktop systems such as iOS, as these system have no USB support. Current solutions such as iPGP can import the user’s private key through Dropbox, but this obviously compromises the private key to a cloud storage provider that the user has no control over. The goal of this specification is to create a secure and easy way to sync the user’s private key over a cloud service that the user does not have to trust completely.&lt;/p&gt;

&lt;p&gt;This specification is split up into the various protocol steps required for key sync.&lt;/p&gt;

&lt;h3 id="deviceregistration"&gt;Device Registration&lt;/h3&gt;

&lt;h4 id="scope"&gt;Scope&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;The device configuration protocol MUST NOT allow multiple devices with the same DeviceSecret.&lt;/li&gt;
&lt;li&gt;The device configuration protocol MUST NOT allow a device to impersonate another one just with the knowledge of its DeviceSecret.&lt;/li&gt;
&lt;li&gt;The device configuration protocol MUST NOT allow a new device to be configured without the possession of the user's keypair.&lt;/li&gt;
&lt;li&gt;The device configuration protocol WILL NOT protect a user from a possible rogue server authorizing devices on the user's behalf.&lt;/li&gt;
&lt;li&gt;The device configuration protocol WILL NOT protect the user from an attacker stealing the DeviceSecret from the server and impersonating the device for that DeviceSecret.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="description"&gt;Description&lt;/h4&gt;

&lt;p&gt;Device registration will exploit the fact that both the user and the server have the user's public key, and the user has the private key. With this knowledge, the server will negotiate a set of random session keys to exchange and authenticate the data sent between the parties.&lt;/p&gt;

&lt;p&gt;A device is referenced by its DeviceSecret and memorable DeviceName. The device secret is a globally unique random string with 256 bits of entropy that is generated using a RNG on the device to avoid collisions. The registration will proceed as showed in the flow diagrams below.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/diagram_1-1.png" alt="Device secret generation"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/diagram_2-1.png" alt="Device Registration"&gt;&lt;/p&gt;

&lt;h3 id="authentication"&gt;Authentication&lt;/h3&gt;

&lt;h4 id="scope"&gt;Scope&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;The authentication protocol MUST protect the DeviceSecret from being reachable by a third party in transit.&lt;/li&gt;
&lt;li&gt;The authentication protocol MUST protect the session keys from being reachable by a third party in transit.&lt;/li&gt;
&lt;li&gt;The authentication protocol MUST avoid reusing session keys.&lt;/li&gt;
&lt;li&gt;The authentication protocol WILL NOT allow authentication without the user having possession of their key pair.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="description"&gt;Description&lt;/h4&gt;

&lt;p&gt;The authentication will exploit the same fact as device registration: using the public key for the user, the server will negotiate a set of session keys to secure future communications. The fact that the user will be able to decrypt the data sent from the server proves that she is the rightful owner of the account.&lt;/p&gt;

&lt;p&gt;Authentication will have, along with the random keys, a challenge that the client needs to respond to. The test for the user is to just send the challenge string back to the server, but wrapped with a different encryption method.&lt;/p&gt;

&lt;p&gt;Once these steps are complete, both the server and the client will have negotiated keys for this session.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/diagram_3-1.png" alt="Authentication"&gt;&lt;/p&gt;

&lt;h3 id="keysync"&gt;Key Sync&lt;/h3&gt;

&lt;h4 id="scope"&gt;Scope&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;The key sync protocol MUST protect the private key from any other party that's not the rightful owner of it, even the server.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id="description"&gt;Description&lt;/h4&gt;

&lt;p&gt;Key synchronization will be done by uploading the key pair encrypted to the Whiteout cloud storage. The key pair will be encrypted with a randomly generated key which will be presented to the user in the form of a QR code or a string of characters. This set of keys will not be uploaded to the cloud, so the key pair will be secure.&lt;/p&gt;

&lt;p&gt;To download the encrypted key pair, the user will request the recovery token that the server assigned to the key at the time of the request. This recovery token will be sent to the user through SMS or email (depending on what is available). With it, the client can download the key pair and use the encryption keys to decipher and import it.&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/diagram_4-1.png" alt="Key sync"&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src="http://blog.whiteout.io/content/images/2015/02/diagram_5-2-1.png" alt="Key sync"&gt;&lt;/p&gt;

&lt;h3 id="diagramreference"&gt;Diagram Reference&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Es(key, data)&lt;/strong&gt;: Symmetric encrypt with key. &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ea(key, data)&lt;/strong&gt;: Asymmetric encrypt data with a public PGP key.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ds(key, ciphertext)&lt;/strong&gt;: Symmetric decrypt ciphertext using key.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pk&lt;/strong&gt;: User’s public PGP key.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;session_keys&lt;/strong&gt;: random encryption keys generated for a session.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id="cipherselection"&gt;Cipher selection&lt;/h3&gt;

&lt;h4 id="blockcipherandmessageauthentication"&gt;Block cipher and message authentication&lt;/h4&gt;

&lt;p&gt;The protocol uses the authenticated &lt;a href="http://en.wikipedia.org/wiki/Galois/Counter_Mode"&gt;AES-256-GCM&lt;/a&gt; mode for symmetric encryption.&lt;/p&gt;

&lt;h4 id="keyderivationforprivatekeyencryption"&gt;Key derivation for private key encryption&lt;/h4&gt;

&lt;p&gt;The private key is encrypted with a 256 bit symmetric key derived from a high entropy code (which is generated for the user) using &lt;a href="http://en.wikipedia.org/wiki/PBKDF2"&gt;PBKDF2-SHA256&lt;/a&gt; (10000 iterations, per user random salt).&lt;/p&gt;

&lt;h4 id="asymmetriccipher"&gt;Asymmetric cipher&lt;/h4&gt;

&lt;p&gt;For asymmetric encryption, &lt;a href="http://en.wikipedia.org/wiki/Pretty_Good_Privacy"&gt;PGP&lt;/a&gt; is used. Key size should be at least 2048 bits.&lt;/p&gt;</content:encoded></item><item><title>Heartbleed and JavaScript Crypto</title><description>&lt;p&gt;Reading the news on Heartbleed in the mainstream media these days got me thinking. It's hard enough to grasp the consequences as a technical person, but trying to explain to my girlfriend why she might want to change the passwords to all of her favorite sites made me think if&lt;/p&gt;</description><link>http://blog.whiteout.io/2014/04/13/heartbleed-and-javascript-crypto/</link><guid isPermaLink="false">0d49675c-4b81-494b-912d-ea2955963f95</guid><category>JavaScript</category><category>Security</category><dc:creator>Tankred Hase</dc:creator><pubDate>Sun, 13 Apr 2014 12:26:00 GMT</pubDate><content:encoded>&lt;p&gt;Reading the news on Heartbleed in the mainstream media these days got me thinking. It's hard enough to grasp the consequences as a technical person, but trying to explain to my girlfriend why she might want to change the passwords to all of her favorite sites made me think if things couldn't be different.&lt;/p&gt;

&lt;p&gt;There is no such thing as bug-free software and anyone writing a complex enough application will experience critical security bugs sooner or later. For most web applications the single line of defense to protect user's data in transit has pretty much been SSL. Much has been said about JavaScript cryptography &lt;a href="http://www.matasano.com/articles/javascript-cryptography/"&gt;here&lt;/a&gt; and &lt;a href="http://tonyarcieri.com/whats-wrong-with-webcrypto"&gt;here&lt;/a&gt;. While these were great blogposts in their time, in the wake of Heartbleed I would like to discuss how JavaScript crypto can  add a valid layer of security if it is deployed correctly.&lt;/p&gt;

&lt;h2 id="threatmodeling"&gt;Threat modeling&lt;/h2&gt;

&lt;p&gt;It's very trendy to criticize JS crypto. And while some arguments are valid, more often than not they are made in a  vacuum and without context. When discussing security mechanisms we should discuss what we're trying to protect and from whom. For web apps I see two main categories:&lt;/p&gt;

&lt;h3 id="servicesyoutrustwithyourdata"&gt;Services you trust with your data&lt;/h3&gt;

&lt;p&gt;I will use an example here. Elster is a system used by the German government which lets citizens do their taxes online. You can visit it at &lt;a href="https://www.elsteronline.de"&gt;https://www.elsteronline.de&lt;/a&gt;. What most people don't know is that Elster uses JS crypto to authenticate users with a passphrase protected Elster certificate which is decrypted in the browser. Before the crypto trolls start getting hungry, let me explain why this makes perfect sense.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;You trust Elster with your tax data and therefor it's ok to trust their web server for authentication.&lt;/strong&gt; This is not a zero knowledge type application where you're trying to protect your data from a service provider. The user does not want to protect his data from Elster. It is actually Elster that wants to verify that you are the person with the corresponding tax identifier.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;The alternative is a Java Applet.&lt;/strong&gt; Yes, this is how the authentication worked before they switched to the Java-free version. And we all know Java is not famous for it's security track record. So given the choice I'd take JS crypto over having to activate Java in my browser any day.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What I'm trying to say with this example is that there are use cases where deploying JavaScript cryptography over a standard web server setup can make perfect sense if you trust the web server with your data. Another example like this is Netflix, which uses WebCrypto and new DRM standards to protect &lt;em&gt;their&lt;/em&gt; premium content. But basically any website that sends the user's password in plaintext to the web server could do hashing client side. This would prevent my girlfriend from having to change all of her passwords when something like Heartbleed happens, since most web servers don't use forward secrecy and the compromise of private SSL keys can be used to decrypt stored traffic after the fact.&lt;/p&gt;

&lt;h3 id="servicesyoudonttrustcompletelywithyourdata"&gt;Services you don't trust (completely) with your data&lt;/h3&gt;

&lt;p&gt;Now that we've established an example for where a normal web server deployment can make sense, lets look at an example of where it does not make sense. &lt;a href="https://whiteout.io"&gt;Whiteout Mail&lt;/a&gt; is an application designed to make PGP encryption easier for average users (I'm a co-founder and developer). When we started designing the app, we thought about deployment via standard web hosting due to ease of use, but that simply does not make sense for this type of app.&lt;/p&gt;

&lt;p&gt;Crypto.cat got a lot of heat by security experts back in the day when it was  served via a web server. You can read the two blogposts I linked at the top or just take &lt;a href="https://www.schneier.com/blog/archives/2012/08/cryptocat.html"&gt;Bruce Schneier's word for it&lt;/a&gt;. This is why crypto.cat changed to an App/Extension based deployment model. This is has several reasons.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;You don't trust the web server with your data.&lt;/strong&gt; If you did you wouldn't be using client side crypto. Every time you click on a link, you're basically "installing" the client side code on your machine to be executed in your browser. The term "drive by web" is usually used here, which basically means that browsers are designed to run arbitrary untrusted code. For zero knowledge type apps, this is not the model we're looking for.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;We want auditable static versions.&lt;/strong&gt; For privacy sensitive applications it is a best practice for software to be installed locally with a static version. This version is signed, downloaded, verified locally by runtimes and can be audited by independent security researchers.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="bestpracticesforjscrypto"&gt;Best practices for JS crypto&lt;/h2&gt;

&lt;p&gt;It is a bit simplistic to split the world into these two categories, but for starters I hope it will help developers working with the new &lt;a href="http://www.w3.org/TR/WebCryptoAPI/"&gt;Web Crypto Apis&lt;/a&gt; to understand where to put their application. To help you get started here is a summary of learnings from our work on Whiteout Mail.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;For zero-knowledge type applications, use packaged apps.&lt;/strong&gt; They are available for &lt;a href="https://developer.mozilla.org/en-US/Marketplace/Publishing/Packaged_apps"&gt;Firefox&lt;/a&gt;, &lt;a href="https://developer.chrome.com/apps/about_apps"&gt;Chrome&lt;/a&gt;, and for mobile there's PhoneGap and Google's &lt;a href="https://github.com/MobileChromeApps/mobile-chrome-apps#run-chrome-apps-on-mobile-using-apache-cordova"&gt;Chrome mobile apps&lt;/a&gt;. Even Microsoft now supports &lt;a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211361"&gt;first class HTML5 apps&lt;/a&gt; with universal apps for Windows 8.1. The advantage besides security is also that your app can be found in the platform's native app store, which is where most users look to find apps anyway.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;For web server deployments use SSL&lt;/strong&gt; with &lt;a href="http://crypto.stackexchange.com/questions/8933/how-can-i-use-ssl-tls-with-perfect-forward-secrecy"&gt;forward secrecy&lt;/a&gt; and activate &lt;a href="https://developer.mozilla.org/en-US/docs/Security/HTTP_Strict_Transport_Security"&gt;HSTS (HTTP Strict Transport Security)&lt;/a&gt; on your web server. Chrome even supports &lt;a href="http://blog.chromium.org/2011/06/new-chromium-security-features-june.html"&gt;certificate pinning&lt;/a&gt; now.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;You should use &lt;a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/"&gt;CSP (Content Security Policy)&lt;/a&gt;&lt;/strong&gt; to protect users against XSS. It's very easy to configure and there is no excuse to not use it. This also forces you to write code with a clean separation of concerns.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Parse data from a server with JSON.parse&lt;/strong&gt; (never with eval) and &lt;strong&gt;escape all strings&lt;/strong&gt; before inserting them into the DOM. If you're using a framework like Angular.js it will escape models automatically before rendering and it's even compatible with CSP!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Always code in ES5 strict mode.&lt;/strong&gt; You can use jshint inside your favorite editor (I use sublime) and tools like grunt make it easy to integrate into your test suite.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write unit tests rigorously.&lt;/strong&gt; I cannot overstate how important this is. You will not catch regressions otherwise.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Do code reviews&lt;/strong&gt; before merging changes to the master branch. This will not only catch some security bugs, but also increase code quality and maintainability.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Do regular security audits&lt;/strong&gt; by independent professionals. They will find stuff. Trust me.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;If you can, open source your code.&lt;/strong&gt; This isn't possible for all business models, but if you can't open source the entire client app, at least open source the crypto bits to allow inspection.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="potentialbenefitsofjscryptoovernativecrypto"&gt;Potential benefits of JS crypto over native crypto&lt;/h2&gt;

&lt;p&gt;I know I'm stretching a bit here, but bear with me for a moment. Here are a few aspects in which I think JS crypto has an advantage over native crypto:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Installed JS crypto apps source can be viewed.&lt;/strong&gt; There is a great blogpost by Jon Callas from Silent Circle about the verifiability of native apps. You should definitely &lt;a href="https://blog.silentcircle.com/reply-to-zooko/"&gt;check it out&lt;/a&gt;. He explains why open sourcing Silent Circle would not solve the problem Ken Thomson first articulated in his &lt;em&gt;Reflections on Trusting Trust&lt;/em&gt;. For interpreted languages such as JavaScript, we don't have this problem as the app is deployed as source code. You still need to trust the browser runtime (which is of course compiled code), but it minimizes the amount of code-bases you need to trust to your OS and your Browser.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;JavaScript is memory safe.&lt;/strong&gt; It seems obvious but often overlooked. The bug that caused Heartbleed was due to a problem that C compilers leave to programmers: memory safety. Although JavaScript is slower in performance due to this property, buffer overflows like the one that caused Heartbleed are a lot less likely to happen in JavaScript.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;One codebase means less room for error.&lt;/strong&gt; I explained this in an &lt;a href="https://github.com/tanx/SafeWith.me/wiki/FAQ"&gt;FAQ for safewith.me&lt;/a&gt; (a hobby project before whiteout.io). The lines of code in any project &lt;a href="http://mayerdan.com/ruby/2012/11/11/bugs-per-line-of-code-ratio/"&gt;correlate to the number of bugs&lt;/a&gt; sleeping in a given software. If there's anything we've learned from Heartbleed, it's that no matter the choice of programming language, the biggest risk is human error. Since we're serving all platforms with a single codebase with JavaScript, were reducing the room for human error and therefor the attack surface. It also makes the code easier to understand and audit by outsiders.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item></channel></rss>