<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>JavaScript - Whiteout Networks</title><description>Our company was founded in 2013 in Munich. Our mission is to provide secure email that is easy to use and runs on all devices.</description><link>http://blog.whiteout.io/</link><generator>Ghost 0.7</generator><lastBuildDate>Mon, 04 Jan 2016 04:54:02 GMT</lastBuildDate><atom:link href="http://blog.whiteout.io/tag/javascript/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Heartbleed and JavaScript Crypto</title><description>&lt;p&gt;Reading the news on Heartbleed in the mainstream media these days got me thinking. It's hard enough to grasp the consequences as a technical person, but trying to explain to my girlfriend why she might want to change the passwords to all of her favorite sites made me think if&lt;/p&gt;</description><link>http://blog.whiteout.io/2014/04/13/heartbleed-and-javascript-crypto/</link><guid isPermaLink="false">0d49675c-4b81-494b-912d-ea2955963f95</guid><category>JavaScript</category><category>Security</category><dc:creator>Tankred Hase</dc:creator><pubDate>Sun, 13 Apr 2014 12:26:00 GMT</pubDate><content:encoded>&lt;p&gt;Reading the news on Heartbleed in the mainstream media these days got me thinking. It's hard enough to grasp the consequences as a technical person, but trying to explain to my girlfriend why she might want to change the passwords to all of her favorite sites made me think if things couldn't be different.&lt;/p&gt;

&lt;p&gt;There is no such thing as bug-free software and anyone writing a complex enough application will experience critical security bugs sooner or later. For most web applications the single line of defense to protect user's data in transit has pretty much been SSL. Much has been said about JavaScript cryptography &lt;a href="http://www.matasano.com/articles/javascript-cryptography/"&gt;here&lt;/a&gt; and &lt;a href="http://tonyarcieri.com/whats-wrong-with-webcrypto"&gt;here&lt;/a&gt;. While these were great blogposts in their time, in the wake of Heartbleed I would like to discuss how JavaScript crypto can  add a valid layer of security if it is deployed correctly.&lt;/p&gt;

&lt;h2 id="threatmodeling"&gt;Threat modeling&lt;/h2&gt;

&lt;p&gt;It's very trendy to criticize JS crypto. And while some arguments are valid, more often than not they are made in a  vacuum and without context. When discussing security mechanisms we should discuss what we're trying to protect and from whom. For web apps I see two main categories:&lt;/p&gt;

&lt;h3 id="servicesyoutrustwithyourdata"&gt;Services you trust with your data&lt;/h3&gt;

&lt;p&gt;I will use an example here. Elster is a system used by the German government which lets citizens do their taxes online. You can visit it at &lt;a href="https://www.elsteronline.de"&gt;https://www.elsteronline.de&lt;/a&gt;. What most people don't know is that Elster uses JS crypto to authenticate users with a passphrase protected Elster certificate which is decrypted in the browser. Before the crypto trolls start getting hungry, let me explain why this makes perfect sense.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;You trust Elster with your tax data and therefor it's ok to trust their web server for authentication.&lt;/strong&gt; This is not a zero knowledge type application where you're trying to protect your data from a service provider. The user does not want to protect his data from Elster. It is actually Elster that wants to verify that you are the person with the corresponding tax identifier.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;The alternative is a Java Applet.&lt;/strong&gt; Yes, this is how the authentication worked before they switched to the Java-free version. And we all know Java is not famous for it's security track record. So given the choice I'd take JS crypto over having to activate Java in my browser any day.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What I'm trying to say with this example is that there are use cases where deploying JavaScript cryptography over a standard web server setup can make perfect sense if you trust the web server with your data. Another example like this is Netflix, which uses WebCrypto and new DRM standards to protect &lt;em&gt;their&lt;/em&gt; premium content. But basically any website that sends the user's password in plaintext to the web server could do hashing client side. This would prevent my girlfriend from having to change all of her passwords when something like Heartbleed happens, since most web servers don't use forward secrecy and the compromise of private SSL keys can be used to decrypt stored traffic after the fact.&lt;/p&gt;

&lt;h3 id="servicesyoudonttrustcompletelywithyourdata"&gt;Services you don't trust (completely) with your data&lt;/h3&gt;

&lt;p&gt;Now that we've established an example for where a normal web server deployment can make sense, lets look at an example of where it does not make sense. &lt;a href="https://whiteout.io"&gt;Whiteout Mail&lt;/a&gt; is an application designed to make PGP encryption easier for average users (I'm a co-founder and developer). When we started designing the app, we thought about deployment via standard web hosting due to ease of use, but that simply does not make sense for this type of app.&lt;/p&gt;

&lt;p&gt;Crypto.cat got a lot of heat by security experts back in the day when it was  served via a web server. You can read the two blogposts I linked at the top or just take &lt;a href="https://www.schneier.com/blog/archives/2012/08/cryptocat.html"&gt;Bruce Schneier's word for it&lt;/a&gt;. This is why crypto.cat changed to an App/Extension based deployment model. This is has several reasons.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;You don't trust the web server with your data.&lt;/strong&gt; If you did you wouldn't be using client side crypto. Every time you click on a link, you're basically "installing" the client side code on your machine to be executed in your browser. The term "drive by web" is usually used here, which basically means that browsers are designed to run arbitrary untrusted code. For zero knowledge type apps, this is not the model we're looking for.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;We want auditable static versions.&lt;/strong&gt; For privacy sensitive applications it is a best practice for software to be installed locally with a static version. This version is signed, downloaded, verified locally by runtimes and can be audited by independent security researchers.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="bestpracticesforjscrypto"&gt;Best practices for JS crypto&lt;/h2&gt;

&lt;p&gt;It is a bit simplistic to split the world into these two categories, but for starters I hope it will help developers working with the new &lt;a href="http://www.w3.org/TR/WebCryptoAPI/"&gt;Web Crypto Apis&lt;/a&gt; to understand where to put their application. To help you get started here is a summary of learnings from our work on Whiteout Mail.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;For zero-knowledge type applications, use packaged apps.&lt;/strong&gt; They are available for &lt;a href="https://developer.mozilla.org/en-US/Marketplace/Publishing/Packaged_apps"&gt;Firefox&lt;/a&gt;, &lt;a href="https://developer.chrome.com/apps/about_apps"&gt;Chrome&lt;/a&gt;, and for mobile there's PhoneGap and Google's &lt;a href="https://github.com/MobileChromeApps/mobile-chrome-apps#run-chrome-apps-on-mobile-using-apache-cordova"&gt;Chrome mobile apps&lt;/a&gt;. Even Microsoft now supports &lt;a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211361"&gt;first class HTML5 apps&lt;/a&gt; with universal apps for Windows 8.1. The advantage besides security is also that your app can be found in the platform's native app store, which is where most users look to find apps anyway.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;For web server deployments use SSL&lt;/strong&gt; with &lt;a href="http://crypto.stackexchange.com/questions/8933/how-can-i-use-ssl-tls-with-perfect-forward-secrecy"&gt;forward secrecy&lt;/a&gt; and activate &lt;a href="https://developer.mozilla.org/en-US/docs/Security/HTTP_Strict_Transport_Security"&gt;HSTS (HTTP Strict Transport Security)&lt;/a&gt; on your web server. Chrome even supports &lt;a href="http://blog.chromium.org/2011/06/new-chromium-security-features-june.html"&gt;certificate pinning&lt;/a&gt; now.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;You should use &lt;a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/"&gt;CSP (Content Security Policy)&lt;/a&gt;&lt;/strong&gt; to protect users against XSS. It's very easy to configure and there is no excuse to not use it. This also forces you to write code with a clean separation of concerns.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Parse data from a server with JSON.parse&lt;/strong&gt; (never with eval) and &lt;strong&gt;escape all strings&lt;/strong&gt; before inserting them into the DOM. If you're using a framework like Angular.js it will escape models automatically before rendering and it's even compatible with CSP!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Always code in ES5 strict mode.&lt;/strong&gt; You can use jshint inside your favorite editor (I use sublime) and tools like grunt make it easy to integrate into your test suite.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Write unit tests rigorously.&lt;/strong&gt; I cannot overstate how important this is. You will not catch regressions otherwise.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Do code reviews&lt;/strong&gt; before merging changes to the master branch. This will not only catch some security bugs, but also increase code quality and maintainability.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Do regular security audits&lt;/strong&gt; by independent professionals. They will find stuff. Trust me.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;If you can, open source your code.&lt;/strong&gt; This isn't possible for all business models, but if you can't open source the entire client app, at least open source the crypto bits to allow inspection.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="potentialbenefitsofjscryptoovernativecrypto"&gt;Potential benefits of JS crypto over native crypto&lt;/h2&gt;

&lt;p&gt;I know I'm stretching a bit here, but bear with me for a moment. Here are a few aspects in which I think JS crypto has an advantage over native crypto:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Installed JS crypto apps source can be viewed.&lt;/strong&gt; There is a great blogpost by Jon Callas from Silent Circle about the verifiability of native apps. You should definitely &lt;a href="https://blog.silentcircle.com/reply-to-zooko/"&gt;check it out&lt;/a&gt;. He explains why open sourcing Silent Circle would not solve the problem Ken Thomson first articulated in his &lt;em&gt;Reflections on Trusting Trust&lt;/em&gt;. For interpreted languages such as JavaScript, we don't have this problem as the app is deployed as source code. You still need to trust the browser runtime (which is of course compiled code), but it minimizes the amount of code-bases you need to trust to your OS and your Browser.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;JavaScript is memory safe.&lt;/strong&gt; It seems obvious but often overlooked. The bug that caused Heartbleed was due to a problem that C compilers leave to programmers: memory safety. Although JavaScript is slower in performance due to this property, buffer overflows like the one that caused Heartbleed are a lot less likely to happen in JavaScript.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;One codebase means less room for error.&lt;/strong&gt; I explained this in an &lt;a href="https://github.com/tanx/SafeWith.me/wiki/FAQ"&gt;FAQ for safewith.me&lt;/a&gt; (a hobby project before whiteout.io). The lines of code in any project &lt;a href="http://mayerdan.com/ruby/2012/11/11/bugs-per-line-of-code-ratio/"&gt;correlate to the number of bugs&lt;/a&gt; sleeping in a given software. If there's anything we've learned from Heartbleed, it's that no matter the choice of programming language, the biggest risk is human error. Since we're serving all platforms with a single codebase with JavaScript, were reducing the room for human error and therefor the attack surface. It also makes the code easier to understand and audit by outsiders.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item></channel></rss>